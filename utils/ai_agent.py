# utils/ai_agent.py - AI Fallback Agent
"""
AI Agent Module for Human-First RAG.

Provides AI responses when human users are offline.
Strictly follows constraints: NO commit, NO negotiate, NO sensitive info.
"""

from datetime import datetime
from typing import Optional, Dict, List, Any
from dataclasses import dataclass
from enum import Enum
import numpy as np

from utils.neo4j_client import Neo4jClient
from utils.rebac import determine_access_scope, AccessScope
from utils.temporal_ranking import calculate_freshness_score, calculate_combined_score
from utils.scheduler import PersonalScheduler, TimeSlot
from utils.embeddings import load_embedder


class AgentConstraint(Enum):
    """Constraints that AI Agent must follow."""
    NO_COMMIT = "no_commit"           # Cannot make commitments
    NO_NEGOTIATE = "no_negotiate"     # Cannot negotiate terms
    NO_SENSITIVE = "no_sensitive"     # Cannot reveal private info
    RAG_ONLY = "rag_only"             # Only use verified RAG info
    DISCLAIMER = "disclaimer"         # Must include disclaimer


@dataclass
class AgentResponse:
    """Response generated by AI Agent."""
    content: str
    sources: List[Dict[str, Any]]
    disclaimer: str
    confidence: float
    constraints_applied: List[AgentConstraint]
    is_fallback: bool = True
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "content": self.content,
            "sources": self.sources,
            "disclaimer": self.disclaimer,
            "confidence": self.confidence,
            "constraints_applied": [c.value for c in self.constraints_applied],
            "is_fallback": self.is_fallback
        }


class AIFallbackAgent:
    """
    AI Agent that responds on behalf of offline users.
    
    Key Principles:
    1. Only use verified/attested claims from RAG
    2. Never commit, negotiate, or reveal sensitive info
    3. Always include disclaimer
    4. Respect ReBAC access control
    """
    
    # Standard disclaimer
    DISCLAIMER = (
        "ğŸ¤– **Pháº£n há»“i tá»± Ä‘á»™ng**: ÄÃ¢y lÃ  cÃ¢u tráº£ lá»i tá»« AI khi {user_name} Ä‘ang váº¯ng máº·t. "
        "ThÃ´ng tin dá»±a trÃªn há»“ sÆ¡ Ä‘Ã£ xÃ¡c thá»±c. AI khÃ´ng thá»ƒ cam káº¿t hay Ä‘Ã m phÃ¡n thay ngÆ°á»i dÃ¹ng."
    )
    
    # Constraints always applied
    DEFAULT_CONSTRAINTS = [
        AgentConstraint.NO_COMMIT,
        AgentConstraint.NO_NEGOTIATE,
        AgentConstraint.NO_SENSITIVE,
        AgentConstraint.RAG_ONLY,
        AgentConstraint.DISCLAIMER
    ]
    
    # Minimum confidence for claims used by AI
    MIN_CONFIDENCE = 0.5
    
    # Keywords that trigger constraint warnings
    COMMIT_KEYWORDS = ["há»©a", "cam káº¿t", "Ä‘á»“ng Ã½", "xÃ¡c nháº­n", "cháº¥p nháº­n", "promise", "commit", "agree"]
    NEGOTIATE_KEYWORDS = ["lÆ°Æ¡ng", "salary", "giÃ¡", "price", "thÆ°Æ¡ng lÆ°á»£ng", "negotiate", "Ä‘iá»u khoáº£n", "terms"]
    
    def __init__(self, neo4j_client: Neo4jClient):
        """
        Initialize AI Agent.
        
        Args:
            neo4j_client: Neo4j database client
        """
        self.client = neo4j_client
        self.scheduler = PersonalScheduler(neo4j_client)
        self._embedder = None
    
    @property
    def embedder(self):
        """Lazy load embedder."""
        if self._embedder is None:
            self._embedder = load_embedder()
        return self._embedder
    
    # ========================================================================
    # Main Response Generation
    # ========================================================================
    
    def generate_response(
        self,
        query: str,
        target_user_id: str,
        requester_id: str
    ) -> AgentResponse:
        """
        Generate AI response on behalf of offline user.
        
        Args:
            query: User's question/message
            target_user_id: User being represented by AI
            requester_id: User asking the question
            
        Returns:
            AgentResponse with content and metadata
        """
        # Get target user info
        target_user = self.client.get_user(target_user_id)
        if not target_user:
            return self._error_response("NgÆ°á»i dÃ¹ng khÃ´ng tá»“n táº¡i")
        
        user_name = target_user.get("name", target_user_id)
        
        # Check for constraint violations in query
        constraint_warnings = self._check_query_constraints(query)
        
        # Determine access scope
        access_scope = determine_access_scope(self.client, requester_id, target_user_id)
        
        # Get relevant claims (respecting access)
        claims = self._get_accessible_claims(target_user_id, access_scope)
        
        if not claims:
            return AgentResponse(
                content=f"Xin lá»—i, {user_name} chÆ°a cÃ³ thÃ´ng tin cÃ´ng khai phÃ¹ há»£p vá»›i cÃ¢u há»i cá»§a báº¡n. "
                        f"Vui lÃ²ng Ä‘á»£i {user_name} online Ä‘á»ƒ trao Ä‘á»•i trá»±c tiáº¿p.",
                sources=[],
                disclaimer=self.DISCLAIMER.format(user_name=user_name),
                confidence=0.0,
                constraints_applied=self.DEFAULT_CONSTRAINTS
            )
        
        # Find relevant claims using semantic search
        relevant_claims = self._semantic_search_claims(query, claims, top_k=3)
        
        # Check if query is about scheduling
        if self._is_scheduling_query(query):
            return self._handle_scheduling_query(query, target_user_id, requester_id, user_name)
        
        # Generate response from claims
        response_content = self._build_response_content(query, relevant_claims, user_name, constraint_warnings)
        
        # Calculate overall confidence
        avg_confidence = np.mean([c.get("confidence_score", 0.5) for c in relevant_claims]) if relevant_claims else 0
        
        return AgentResponse(
            content=response_content,
            sources=[{"claim_id": c.get("claim_id"), "summary": c.get("content_summary")} for c in relevant_claims],
            disclaimer=self.DISCLAIMER.format(user_name=user_name),
            confidence=float(avg_confidence),
            constraints_applied=self.DEFAULT_CONSTRAINTS
        )
    
    # ========================================================================
    # Claim Retrieval & Search
    # ========================================================================
    
    def _get_accessible_claims(self, user_id: str, access_scope: AccessScope) -> List[Dict]:
        """
        Get claims accessible based on ReBAC.
        
        Only returns verified/attested claims for AI use.
        """
        allowed_tags = access_scope.allowed_tags if access_scope else ["public"]
        
        query = """
        MATCH (u:User {user_id: $user_id})-[:MAKES_CLAIM]->(c:Claim)
        WHERE c.access_level IN $allowed_tags
        AND c.status IN ['verified', 'attested', 'self_declared']
        AND c.confidence_score >= $min_confidence
        OPTIONAL MATCH (c)-[:ABOUT]->(e:Entity)
        RETURN c, collect(DISTINCT e.name) as entities
        ORDER BY c.confidence_score DESC
        """
        
        result = self.client.run_query(query, {
            "user_id": user_id,
            "allowed_tags": allowed_tags,
            "min_confidence": self.MIN_CONFIDENCE
        })
        
        claims = []
        for row in result:
            claim = dict(row["c"])
            claim["entities"] = row.get("entities", [])
            claims.append(claim)
        
        return claims
    
    def _semantic_search_claims(self, query: str, claims: List[Dict], top_k: int = 3) -> List[Dict]:
        """
        Find most relevant claims using semantic similarity.
        """
        if not claims:
            return []
        
        # Embed query
        query_embedding = self.embedder.encode([query])[0]
        
        # Score claims
        scored_claims = []
        for claim in claims:
            content = claim.get("content_summary", "")
            if not content:
                continue
            
            content_embedding = self.embedder.encode([content])[0]
            similarity = float(np.dot(query_embedding, content_embedding) / 
                             (np.linalg.norm(query_embedding) * np.linalg.norm(content_embedding) + 1e-8))
            
            scored_claims.append((claim, similarity))
        
        # Sort by similarity
        scored_claims.sort(key=lambda x: x[1], reverse=True)
        
        # Return top-k with minimum threshold
        return [c for c, s in scored_claims[:top_k] if s > 0.2]
    
    # ========================================================================
    # Response Building
    # ========================================================================
    
    def _build_response_content(
        self, 
        query: str, 
        claims: List[Dict], 
        user_name: str,
        constraint_warnings: List[str]
    ) -> str:
        """Build response content from relevant claims."""
        
        parts = []
        
        # Add constraint warnings if any
        if constraint_warnings:
            parts.append("âš ï¸ **LÆ°u Ã½**: " + " ".join(constraint_warnings))
            parts.append("")
        
        if not claims:
            parts.append(f"Xin lá»—i, khÃ´ng tÃ¬m tháº¥y thÃ´ng tin liÃªn quan trong há»“ sÆ¡ cá»§a {user_name}.")
            return "\n".join(parts)
        
        # Introduction
        parts.append(f"Dá»±a trÃªn há»“ sÆ¡ Ä‘Ã£ xÃ¡c thá»±c cá»§a **{user_name}**:\n")
        
        # Add relevant claims
        for i, claim in enumerate(claims, 1):
            content = claim.get("content_summary", "")
            confidence = claim.get("confidence_score", 0)
            status = claim.get("status", "")
            entities = claim.get("entities", [])
            
            # Status indicator
            status_emoji = {
                "verified": "âœ…",
                "attested": "ğŸ”",
                "self_declared": "ğŸ“"
            }.get(status, "ğŸ“")
            
            parts.append(f"**{i}. {content}**")
            parts.append(f"   {status_emoji} {status.title()} | Äá»™ tin cáº­y: {confidence:.0%}")
            
            if entities:
                parts.append(f"   ğŸ·ï¸ {', '.join(entities)}")
            
            parts.append("")
        
        # Conclusion
        parts.append("---")
        parts.append(f"ğŸ’¡ *Äá»ƒ biáº¿t thÃªm chi tiáº¿t hoáº·c tháº£o luáº­n trá»±c tiáº¿p, vui lÃ²ng Ä‘á»£i khi {user_name} online.*")
        
        return "\n".join(parts)
    
    # ========================================================================
    # Constraint Checking
    # ========================================================================
    
    def _check_query_constraints(self, query: str) -> List[str]:
        """Check if query triggers constraint warnings."""
        warnings = []
        query_lower = query.lower()
        
        # Check for commitment requests
        if any(kw in query_lower for kw in self.COMMIT_KEYWORDS):
            warnings.append("AI khÃ´ng thá»ƒ Ä‘Æ°a ra cam káº¿t thay ngÆ°á»i dÃ¹ng.")
        
        # Check for negotiation requests
        if any(kw in query_lower for kw in self.NEGOTIATE_KEYWORDS):
            warnings.append("AI khÃ´ng thá»ƒ thÆ°Æ¡ng lÆ°á»£ng vá» lÆ°Æ¡ng hay Ä‘iá»u khoáº£n.")
        
        return warnings
    
    def _is_scheduling_query(self, query: str) -> bool:
        """Check if query is about scheduling."""
        schedule_keywords = [
            "háº¹n", "lá»‹ch", "gáº·p", "phá»ng váº¥n", "meeting", "schedule", 
            "appointment", "interview", "call", "gá»i", "há»p"
        ]
        return any(kw in query.lower() for kw in schedule_keywords)
    
    # ========================================================================
    # Scheduling Handling
    # ========================================================================
    
    def _handle_scheduling_query(
        self,
        query: str,
        target_user_id: str,
        requester_id: str,
        user_name: str
    ) -> AgentResponse:
        """Handle scheduling-related queries."""
        
        # Get available slots for next 7 days
        from datetime import timedelta
        available_slots = []
        
        for days_ahead in range(1, 8):
            date = datetime.now() + timedelta(days=days_ahead)
            slots = self.scheduler.get_available_slots(target_user_id, date)
            available_slots.extend([s for s in slots if s.is_available][:2])  # Max 2 per day
            
            if len(available_slots) >= 5:
                break
        
        if not available_slots:
            content = (
                f"ğŸ“… Xin lá»—i, khÃ´ng thá»ƒ xÃ¡c Ä‘á»‹nh lá»‹ch trá»‘ng cá»§a {user_name} lÃºc nÃ y.\n\n"
                f"Vui lÃ²ng:\n"
                f"1. Äá»£i {user_name} online Ä‘á»ƒ tháº£o luáº­n trá»±c tiáº¿p\n"
                f"2. Hoáº·c Ä‘á»ƒ láº¡i tin nháº¯n vá»›i thá»i gian báº¡n mong muá»‘n"
            )
            return AgentResponse(
                content=content,
                sources=[],
                disclaimer=self.DISCLAIMER.format(user_name=user_name),
                confidence=0.3,
                constraints_applied=self.DEFAULT_CONSTRAINTS
            )
        
        # Propose meeting
        result = self.scheduler.ai_propose_meeting(
            on_behalf_of_id=target_user_id,
            with_user_id=requester_id,
            suggested_slots=available_slots[:3],
            title="Meeting Request"
        )
        
        # Build response
        parts = [
            f"ğŸ“… **Äá» xuáº¥t lá»‹ch háº¹n vá»›i {user_name}**\n",
            "Dá»±a trÃªn lá»‹ch trá»‘ng, cÃ¡c thá»i Ä‘iá»ƒm cÃ³ thá»ƒ:\n"
        ]
        
        for i, slot in enumerate(available_slots[:3], 1):
            parts.append(f"  {i}. {slot.start_time.strftime('%H:%M %d/%m/%Y')}")
        
        parts.extend([
            "\n---",
            f"âš ï¸ **Quan trá»ng**: AI Ä‘Ã£ ghi nháº­n yÃªu cáº§u nhÆ°ng **KHÃ”NG thá»ƒ xÃ¡c nháº­n** lá»‹ch háº¹n.",
            f"Lá»‹ch háº¹n cáº§n Ä‘Æ°á»£c {user_name} xÃ¡c nháº­n khi online."
        ])
        
        return AgentResponse(
            content="\n".join(parts),
            sources=[],
            disclaimer=self.DISCLAIMER.format(user_name=user_name),
            confidence=0.7,
            constraints_applied=self.DEFAULT_CONSTRAINTS
        )
    
    # ========================================================================
    # Error Handling
    # ========================================================================
    
    def _error_response(self, message: str) -> AgentResponse:
        """Generate error response."""
        return AgentResponse(
            content=f"âŒ Lá»—i: {message}",
            sources=[],
            disclaimer="",
            confidence=0.0,
            constraints_applied=[]
        )
    
    # ========================================================================
    # Profile Summary for Visitors
    # ========================================================================
    
    def get_public_profile_summary(self, user_id: str) -> str:
        """
        Get public profile summary for a user.
        
        Used when visitor asks "Who is this person?"
        """
        user = self.client.get_user(user_id)
        if not user:
            return "NgÆ°á»i dÃ¹ng khÃ´ng tá»“n táº¡i."
        
        user_name = user.get("name", user_id)
        bio = user.get("bio", "")
        
        # Get public claims
        claims = self._get_accessible_claims(user_id, AccessScope(
            viewer_id="public",
            target_id=user_id,
            relationship_type="STRANGER",
            allowed_tags=["public"]
        ))
        
        parts = [f"## ğŸ‘¤ Há»“ sÆ¡ cÃ´ng khai: {user_name}\n"]
        
        if bio:
            parts.append(f"*{bio}*\n")
        
        if claims:
            parts.append("### Skills & Experience\n")
            for claim in claims[:5]:
                content = claim.get("content_summary", "")
                confidence = claim.get("confidence_score", 0)
                status_emoji = "âœ…" if claim.get("status") == "verified" else "ğŸ“"
                parts.append(f"- {status_emoji} {content} ({confidence:.0%})")
        else:
            parts.append("*ChÆ°a cÃ³ thÃ´ng tin cÃ´ng khai.*")
        
        parts.extend([
            "\n---",
            f"*ÄÃ¢y lÃ  thÃ´ng tin cÃ´ng khai. LiÃªn há»‡ trá»±c tiáº¿p vá»›i {user_name} Ä‘á»ƒ biáº¿t thÃªm chi tiáº¿t.*"
        ])
        
        return "\n".join(parts)
